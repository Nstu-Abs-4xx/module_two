//
//  main.c
// c 50
//
//  Created by Stanislav Klepikov on 17.10.2024.
//

#include <stdio.h>

//this is 13
/* int main(void)
 {
     setlocale(LC_ALL, "Russian");
     int a = 56784;
     int n;
     int s;
     int k;
     for (n = a, s = 0; n != 0; n = n / 10)
     {
         k = n % 10;
         if (k > s)
         {
             s = k;
         }
     }
         printf("%d", s);*/
//this is 14
/* int main(void)
 {
     int a = 1230;
     int n;
     int s;
     int k;
     for (n = a, s = a; n != 0; n = n/10)
     {
         k = n % 10;
         s = s + k;
     }
     printf("π%d and %d\n", s, k);
 }*/
//this is 15
/*int main(void)
 {
     int n;
     int s;
     int a = 987654321;
     int k;
     for (n = a, s = 0; n != 0; n = n / 10)
     {
         k = n % 10;
         s = s * 10 + k;
     }
     printf("%d", s);
 }*/
//this is 16
//
/*
 int main(void)
 {
     int j;
     int a;
     int n;
     int k;
     int s;
     int A[10];
     for (j = 0, a = 10; a < 30000; a++)
     {

         for (n = a, s = 0; n != 0; n = n / 10)

         {
             k = n % 10;
             s = s + k;
         }

         if (a == s * s * s)
         {
             A[j++] = a;
             printf("π%‚ %d\n", A[j-1], s);
         }
     }
 */
//this is 17
/*
 int main(void) {
     setlocale(LC_ALL, "Russian");
     int A[100], n, i, j;
     printf("¬‚Â‰ËÚÂ ‡ÁÏÂ Ï‡ÒÒË‚‡: ");
     scanf_s("%d", &n);
     printf("¬‚Â‰ËÚÂ ˝ÎÂÏÂÌÚ˚ Ï‡ÒÒË‚‡:\n");
     for (i = 0; i < n; i++)
     {
         scanf_s("%d", &A[i]);
     }
     for (i = 0; i < n; i++)
     {
         if (A[i] < 0)
         {
         
             for (j = i; j < n - 1; j++) {
                 A[j] = A[j + 1];
             }
             n--;
             i--;
         }
     }
     printf("»ÚÓ„Ó‚˚È Ï‡ÒÒË‚:\n");
     for (i = 0; i < n; i++) {
         printf("%d ", A[i]);
     }
 
 */
// this is 18
/* int main(void) {
 int v = 100;  // предел числа
 int A[100];   // массив для хранения палиндромов
 int j = 0, a, n, s, k;
 
 for (a = 10; a < v; a++) {
 for (n = a, s = 0; n != 0; n = n / 10) {
 k = n % 10;
 s = s * 10 + k;
 }
 if (a == s) {
 A[j++] = a;
 }
 }
 
 
 printf("Палиндромы от 10 до %d:\n", v);
 for (int i = 0; i < j; i++) {
 printf("%d ", A[i]);
 }
 printf("\n");
 
 return 0;
 }
 */
//this is 19
/*
 int main(void) {
 int A[100], n, i, j;
 
 printf("Введите размер массива: ");
 scanf("%d", &n);
 printf("Введите элементы массива:\n");
 for (i = 0; i < n; i++) {
 scanf("%d", &A[i]);
 }
 
 for (i = 0; i < n; i++) {
 if (A[i] < 0) {
 for (j = i; j < n - 1; j++) {
 A[j] = A[j + 1];
 }
 n--;
 i--;
 }
 }
 printf("Результирующий массив:\n");
 for (i = 0; i < n; i++) {
 printf("%d ", A[i]);
 }
 
 return 0;
 }
 */
//this is 20
/*
 int main(void) {
    int A[] = {3, 7, 2, 9, 5};
    int n = sizeof(A)/sizeof(A[0]);
    int i, j, k;

    
    for (i = 1, k = 0; i < n; i++) {
        if (A[i] > A[k]) {
            k = i;
        }
    }
    for (j = k; j < n - 1; j++) {
        A[j] = A[j + 1];
    }
    
    n--;
    printf("Массив после удаления максимального элемента: ");
    for (i = 0; i < n; i++) {
        printf("%d ", A[i]);
    }

    return 0;
}
*/
//this is 21
/*
 int main(void) {
    int A[100];  // Массив для хранения простых чисел, размер можно регулировать
    int i, a, n, v;

    printf("Введите число v: ");
    scanf("%d", &v);  // Ввод границы, до которой будем искать простые числа

    for (i = 0, a = 2; a < v; a++) {
        for (n = 2; n < a; n++) {
            if (a % n == 0) break;  // Если a делится на n, это не простое число
        }
        if (n == a) {
            A[i++] = a;  // Если ни одно число не делит a, значит, это простое число
        }
    }
    A[i] = 0;  // Указываем конец массива простых чисел

    // Выводим найденные простые числа
    printf("Простые числа меньше %d: ", v);
    for (i = 0; A[i] != 0; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");

    return 0;
}
*/
//this is 22
/* int main(void) {
 int v = 20;    // Задаём границу поиска простых чисел
 int A[100];    // Массив для хранения простых чисел (макс. 100 чисел)
 int i, a, s, n;
 
 // Поиск простых чисел
 for (i = 0, a = 2; a < v; a++) {
 s = 0;  // Обнуляем флаг перед проверкой нового числа
 for (n = 2; n < a; n++) {
 if (a % n == 0) {  // Если число делится на любое другое число
 s = 1;         // Это не простое число, ставим флаг
 break;         // Прерываем цикл
 }
 }
 if (s == 0) {   // Если флаг остался 0, то число простое
 A[i++] = a; // Сохраняем число в массив
 }
 }
 A[i] = 0;  // Добавляем 0 в конец массива как маркер окончания
 
 // Выводим простые числа
 printf("Простые числа меньше %d: ", v);
 for (int j = 0; A[j] != 0; j++) {
 printf("%d ", A[j]);
 }
 printf("\n");
 
 return 0;
 }
 */
//this is 23

/* int main(void) {
 int A[100]; // Массив для хранения чисел
 int B[100]; // Массив для хранения простых чисел
 int n, i, j = 0, m;
 
 // Заполнение массива A
 printf("Введите количество элементов в массиве A: ");
 scanf("%d", &n);
 
 printf("Введите %d элементов массива A:\n", n);
 for (i = 0; i < n; i++) {
 scanf("%d", &A[i]);
 }
 
 // Поиск простых чисел
 for (i = 0; i < n; i++) {
 for (m = 2; m < A[i]; m++) {
 if (A[i] % m == 0) break;
 }
 if (m == A[i]) B[j++] = A[i]; // Если m равно A[i], то это простое число
 }
 
 B[j] = 0; // Завершаем массив B нулем
 
 // Вывод простых чисел
 printf("Простые числа в массиве B:\n");
 for (i = 0; i < j; i++) {
 printf("%d ", B[i]);
 }
 printf("\n");
 
 return 0;
 }
 */
 //this is 24
 
 
/* int main(void) {
     int A[100]; // Исходный массив
     int B[100]; // Массив для простых чисел
     int n, i, j = 0, s, m;

     // Ввод размера массива
     printf("Введите количество элементов в массиве A: ");
     scanf("%d", &n);

     // Ввод элементов массива A
     printf("Введите элементы массива A:\n");
     for (i = 0; i < n; i++) {
         scanf("%d", &A[i]);
     }

     // Проверка на простые числа
     for (i = 0; i < n; i++) {
         s = 0; // Сброс флага
         if (A[i] < 2) continue; // Пропуск чисел меньше 2
         for (m = 2; m * m <= A[i]; m++) { // Проверка делителей до корня из A[i]
             if (A[i] % m == 0) {
                 s = 1; // Не простое число
                 break;
             }
         }
         if (s == 0) B[j++] = A[i]; // Запись простого числа в B
     }
     B[j] = 0; // Завершение массива B

     // Вывод простых чисел
     printf("Простые числа в массиве B:\n");
     for (i = 0; B[i] != 0; i++) {
         printf("%d ", B[i]);
     }
     printf("\n");

     return 0;
 }
*/
//this is 25
/*
void removePrimes(int A[], int *n) {
    for (int i = 0; i < *n; i++) {
        int isPrime = 1; // Предполагаем, что число простое
        for (int m = 2; m * m <= A[i]; m++) { // Оптимизированная проверка
            if (A[i] % m == 0) {
                isPrime = 0; // Число не простое
                break;
            }
        }
        if (isPrime && A[i] > 1) { // Если число простое и больше 1
            for (int j = i; j < *n - 1; j++) {
                A[j] = A[j + 1]; // Сдвигаем элементы влево
            }
            (*n)--; // Уменьшаем размер массива
            i--; // Проверяем следующий элемент на той же позиции
        }
    }
}

int main(void) {
    int A[] = {2, 3, 4, 5, 6, 7, 8, 9, 10}; // Пример массива
    int n = sizeof(A) / sizeof(A[0]); // Определяем количество элементов в массиве

    removePrimes(A, &n); // Удаляем простые числа

    // Выводим оставшиеся элементы
    for (int i = 0; i < n; i++) {
        printf("%d ", A[i]);
    }

    return 0;
}
*/
// this is 26
/*
void remove_non_prime(int A[], int *n) {
    int i, j, s, m;
    
    for (j = 0, i = 0; i < *n; i++) {
        // Предполагаем, что A[i] >= 2 для простоты
        for (s = 0, m = 2; m * m <= A[i]; m++) {  // Оптимизация: проверяем до корня
            if (A[i] % m == 0) {
                s = 1;
                break;
            }
        }
        if (s == 0) {  // Если число простое
            for (j = i; j < *n - 1; j++)
                A[j] = A[j + 1];
            (*n)--;  // Уменьшаем размер массива
            i--;     // Корректируем индекс
        }
    }
}

int main(void) {
    int A[] = {2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(A) / sizeof(A[0]);
    
    remove_non_prime(A, &n);
    
    // Печатаем результат
    for (int i = 0; i < n; i++) {
        printf("%d ", A[i]);
    }
    
    return 0;
}
*/
// this is 27
/*
void factorize(int n, int A[]) {
    int i = 0, val = n;

    // Проверка на неотрицательность
    if (val <= 0) {
        printf("Число должно быть положительным\n");
        return;
    }

    // Вынесение проверки на четность
    while (val % 2 == 0) {
        A[i++] = 2;
        val /= 2;
    }

    // Поиск нечетных делителей
    for (int m = 3; m * m <= val; m += 2) {
        while (val % m == 0) {
            A[i++] = m;
            val /= m;
        }
    }

    // Если осталось неразложенное число, оно является простым
    if (val > 1) {
        A[i++] = val;
    }

    A[i] = 0; // Завершающий нулевой элемент для обозначения конца массива
}

int main(void) {
    int n = 36;
    int A[100]; // Достаточно большой массив для большинства случаев

    factorize(n, A);

    printf("Разложение числа %d на простые множители:\n", n);
    for (int i = 0; A[i] != 0; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");

    return 0;
}
*/
//this is 28
/*
int main(void) {
    int A[] = {12, 18, 24}; // Пример массива
    int n = sizeof(A) / sizeof(A[0]); // Вычисление размера массива
    int v = A[0] + 1;
    int i, s;

    do {
        v--;
        for (i = 0, s = 0; i < n; i++) {
            if (A[i] % v != 0) {
                s = 1;
                break;
            }
        }
    } while (s == 1);

    printf("Наибольший общий делитель: %d\n", v);

    return 0;
}
*/
//this is 29
/*
int main() {
    int n = 5; // размер массива
    int v = 3; // начальное значение v
    int A[] = {1, 2, 3, 4, 5}; // пример массива A

    for (int i = 0; i < n; i++) {
        if (A[i] % v != 0) {
            v--;
            i = -1; // сброс i для повторной проверки всего массива
        }
    }

    printf("Конечное значение v: %d\n", v);
    return 0;
}
*/
//this is 30

/*
 int main() {
 int v; // Верхняя граница
 int m = 100; // Максимальное количество простых чисел
 int A[100]; // Массив для хранения простых чисел
 int i = 0; // Индекс для массива A
 int a, j, s;
 
 printf("Введите верхнюю границу (v): ");
 scanf("%d", &v);
 
 for (i = 0, a = 2; a < v && i < m - 1; a++) {
 for (s = 0, j = 0; j < i; j++)
 if (a % A[j] == 0) { s = 1; break; }
 if (s == 0) A[i++] = a;
 }
 
 A[i] = 0; // Завершение массива
 
 // Вывод найденных простых чисел
 printf("Простые числа меньше %d: ", v);
 for (int k = 0; A[k] != 0; k++) {
 printf("%d ", A[k]);
 }
 printf("\n");
 
 return 0;
 }
 */
//this is 31
/*
int find_first_duplicate(int c[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (c[i] == c[j]) {
                return i; // Возвращаем индекс первого дубликата
            }
        }
    }
    return -1; // Если дубликатов нет, возвращаем -1
}

int main() {
    int c[] = {1, 2, 3, 4, 2}; // Пример массива
    int n = sizeof(c) / sizeof(c[0]); // Определение размера массива

    int result = find_first_duplicate(c, n);
    if (result != -1) {
        printf("Первый дубликат найден на индексе: %d\n", result);
    } else {
        printf("Дубликаты не найдены.\n");
    }

    return 0;
}
*/
//this is 32
/*
int main() {
    int n; // размер массива
    printf("Введите размер массива: ");
    scanf("%d", &n);
    
    int c[n]; // массив
    printf("Введите элементы массива:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &c[i]);
    }

    int s = 0, b = 0; // s - максимальное количество вхождений, b - индекс наиболее частого элемента
    for (int i = 0; i < n; i++) {
        int k = 0; // сбрасываем счетчик
        for (int j = 0; j < n; j++) {
            if (c[i] == c[j]) {
                k++;
            }
        }
        if (k > s) {
            s = k;
            b = i;
        }
    }

    printf("Элемент %d встречается %d раз.\n", c[b], s);
    return 0;
}
*/
//this is 33
/*
int main(void) {
    int n; // размер массива
    printf("Введите размер массива: ");
    scanf("%d", &n);
    
    int c[n]; // массив
    printf("Введите элементы массива:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &c[i]);
    }

    int s = 0, b = 0; // s - максимальное количество вхождений, b - индекс наиболее частого элемента
    for (int i = 0; i < n; i++) {
        int k = 0; // сбрасываем счетчик
        for (int j = 0; j < n; j++) {
            if (c[i] == c[j]) {
                k++;
            }
        }
        if (k > s) {
            s = k;
            b = i;
        }
    }

    printf("Элемент %d встречается %d раз.\n", c[b], s);
    return 0;
}
*/
//this is 34
/*
 int calculate_k(int n) {
     int k, m;
     for (k = 0, m = 1; m <= n; k++, m = m * 2);
     return k - 1;
 }

 int main() {
     int n = 10;
     int result = calculate_k(n);
     printf("Max k such that 2^k <= %d is %d\n", n, result);
     return 0;
 }
 */
//this is 35
/*
 void reverseArray(int *c, int n) {
     int i, j, k;
     for (i = 0, j = n - 1; i < j; i++, j--) {
         k = c[i];
         c[i] = c[j];
         c[j] = k;
     }
 }

 int main() {
     int c[] = {1, 2, 3, 4, 5};
     int n = sizeof(c) / sizeof(c[0]);

     printf("Original array: ");
     for (int i = 0; i < n; i++) {
         printf("%d ", c[i]);
     }
     printf("\n");

     reverseArray(c, n);

     printf("Reversed array: ");
     for (int i = 0; i < n; i++) {
         printf("%d ", c[i]);
     }
     printf("\n");

     return 0;
 }
 */
//this is 36
/*
int find_middle_element(int c[], int n) {
    for (int i = 0; i < n; i++) {
        int k1 = 0, k2 = 0;
        for (int j = 0; j < n; j++) {
            if (c[i] != c[j]) {
                if (c[i] < c[j])
                    k1++;
                else
                    k2++;
            }
        }
        if (k1 == k2)
            return i;  // Возвращает индекс элемента, у которого количество меньших и больших элементов одинаково.
    }
    return -1;  // Если не найдено подходящего элемента.
}

int main(void) {
    int c[] = {3, 1, 2, 4};
    int n = sizeof(c) / sizeof(c[0]);
    int index = find_middle_element(c, n);
    if (index != -1) {
        printf("Middle element is at index: %d\n", index);
    } else {
        printf("No middle element found.\n");
    }
    return 0;
}
*/
//this is 37
/*
 
 int main() {
     int n; // количество элементов
     printf("Введите количество элементов: ");
     scanf("%d", &n);

     int c[n]; // массив для хранения элементов
     printf("Введите элементы массива: ");
     for (int i = 0; i < n; i++) {
         scanf("%d", &c[i]);
     }

     int s = 0; // максимальное количество повторений
     int b = 0; // индекс элемента, который повторяется максимальное количество раз

     // Основной цикл для поиска элемента с максимальным количеством повторений
     for (int i = 0; i < n - 1; i++) {
         int m = 0; // счетчик для повторений текущего элемента
         for (int j = i + 1; j < n; j++) {
             if (c[i] == c[j]) m++;
         }
         if (m > s) {
             s = m; // обновление максимального количества повторений
             b = i; // обновление индекса элемента
         }
     }

     // Печать результата
     if (s > 0) {
         printf("Элемент %d повторяется %d раз.\n", c[b], s + 1); // +1 для учета самого элемента
     } else {
         printf("Нет повторяющихся элементов.\n");
     }

     return 0;
 }*/
//this is 38
/*
int main(void) {
    int c[] = {1, 1, 2, 2, 2, 3, 4, 4}; // Пример массива
    int n = sizeof(c) / sizeof(c[0]); // Определение размера массива
    int i, k = 0, m = 0, b = 0; // Инициализация переменных

    for (i = 0; i < n - 1; i++) {
        if (c[i] == c[i + 1]) {
            k++;
        } else {
            if (k > m) {
                m = k; // Обновление максимальной длины
                b = i - k; // Начало последовательности
            }
            k = 0; // Сброс счетчика
        }
    }

    // Последняя проверка для конца массива
    if (k > m) {
        m = k;
        b = n - k - 1;
    }

    // Вывод результатов
    printf("Максимальная длина последовательности: %d\n", m + 1);
    printf("Начальный индекс последовательности: %d\n", b);
    
    return 0;
}
*/

//this is 39
/*
int main() {
    int n;
    printf("Введите количество элементов массива: ");
    scanf("%d", &n);
    
    int A[n]; // Массив для хранения n элементов
    printf("Введите элементы массива: ");
    for (int j = 0; j < n; j++) {
        scanf("%d", &A[j]); // Заполняем массив элементами
    }
    
    int s = 0, i = 0; // Инициализация переменных
    for (i = 0; i < n; i++) {
        if (A[i] < 0) continue; // Пропускаем отрицательные элементы
        if (A[i] == 0) break;    // Останавливаем цикл, если встретили 0
        s = s + A[i];            // Суммируем положительные элементы
    }

    printf("Сумма положительных элементов до первого нуля: %d\n", s);
    return 0;
}
*/
//this is 40
/*
int main(void) {
    int A[] = {1, 2, 3, -1, 4}; // Пример массива
    int n = sizeof(A) / sizeof(A[0]); // Определение размера массива
    int s = 0, i;

    for (s = 0, i = 0; i < n && A[i] > 0; i++) {
        s = s + A[i];
    }

    printf("Сумма положительных элементов: %d\n", s);
    return 0;
}
*/
//this is 41
/*


 int main(void) {
     int A[] = {1, 2, 3, -1, 4, 5}; // Пример массива
     int n = sizeof(A) / sizeof(A[0]); // Размер массива
     int k, s, i;

     for (k = 0, s = 0, i = 0; i < n && k == 0; i++) {
         if (A[i] < 0) k = 1; // Если элемент отрицательный, устанавливаем флаг
         s = s + A[i]; // Суммируем элементы
     }

     printf("Сумма положительных элементов: %d\n", s); // Выводим сумму
     return 0;
 }
 */
//this is 42
/*int splitArray(int A[], int n) {
 int s1 = 0, s2 = 0;
 int i = 0, j = n - 1;

 // Выполняем цикл, пока i не превысит j
 for (; i <= j;) {
     if (s1 < s2) {
         s1 += A[i]; // добавляем к первой сумме
         i++; // переходим к следующему элементу с начала
     } else {
         s2 += A[j]; // добавляем ко второй сумме
         j--; // переходим к следующему элементу с конца
     }
 }

 return i; // возвращаем количество обработанных элементов
}

int main() {
 int A[] = {1, 2, 3, 4, 5}; // пример массива
 int n = sizeof(A) / sizeof(A[0]); // размер массива
 int result = splitArray(A, n);
 printf("Number of processed elements: %d\n", result);
 return 0;
}*/
//this is 43
/*
int main() {
    int n; // Размер массива
    printf("Введите размер массива: ");
    scanf("%d", &n);

    int A[n]; // Объявление массива A
    printf("Введите %d элементов массива:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &A[i]); // Ввод элементов массива
    }

    int s = 0; // Инициализация суммы
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            s = s + A[i]; // Если индекс четный, добавляем элемент
        } else {
            s = s - A[i]; // Если индекс нечетный, вычитаем элемент
        }
    }

    printf("Результат: %d\n", s); // Вывод результата
    return 0;
}
*/
//this is 44
/*
 void selection_sort(int A[], int n, int B[]) {
     int j, k, i;

     for(j = 0; n != 0; j++) {
         for(k = 0, i = 1; i < n; i++) {
             if (A[i] < A[k]) {
                 k = i; // Находим индекс минимального элемента
             }
         }
         B[j] = A[k]; // Сохраняем минимальный элемент в B
         for(; k < n - 1; k++) {
             A[k] = A[k + 1]; // Сдвигаем элементы влево
         }
         n--; // Уменьшаем количество элементов
     }
 }

 int main() {
     int A[] = {64, 25, 12, 22, 11}; // Исходный массив
     int n = sizeof(A) / sizeof(A[0]); // Количество элементов в массиве A
     int B[n]; // Массив для отсортированных элементов

     selection_sort(A, n, B);

     printf("Отсортированный массив B:\n");
     for(int i = 0; i < sizeof(B)/sizeof(B[0]); i++) {
         printf("%d ", B[i]); // Выводим отсортированный массив
     }

     return 0;
 }
 */
//this is 45
/* void find_min_elements(int A[], int B[], int n) {
 int max, j, k, i;

 // Находим максимальное значение в массиве A
 for(j = 0, max = A[0]; j < n; j++) {
     if (A[j] > max) {
         max = A[j];
     }
 }

 // Находим n наименьших элементов и сохраняем их в массив B
 for(j = 0; j < n; j++) {
     for (k = 0, i = 1; i < n; i++) {
         if (A[i] < A[k]) {
             k = i;
         }
     }
     B[j] = A[k];  // Сохраняем наименьший элемент в B
     A[k] = max + 1; // Заменяем элемент в A
 }
}

int main() {
 int A[] = {5, 2, 9, 1, 5, 6};
 int n = sizeof(A) / sizeof(A[0]);
 int B[n];

 find_min_elements(A, B, n);

 printf("Найденные наименьшие элементы:\n");
 for(int i = 0; i < n; i++) {
     printf("%d ", B[i]);
 }
 printf("\n");

 return 0;
}*/
//this is 46
/*
void selectionSort(int A[], int size) {
    int n = size;  // Инициализация количества элементов
    int k, i, c;  // k - индекс минимального элемента, i - индекс для перебора, c - временная переменная для обмена

    while (n != 0) {
        k = 0;  // Предполагаем, что первый элемент - минимальный
        for (i = 1; i < n; i++) {
            if (A[i] < A[k]) {
                k = i;  // Находим индекс минимального элемента
            }
        }
        // Меняем местами минимальный элемент и последний не отсортированный
        c = A[k];
        A[k] = A[n - 1];
        A[n - 1] = c;

        n--;  // Уменьшаем количество не отсортированных элементов
    }
}

int main(void) {
    int A[] = {64, 25, 12, 22, 11};
    int size = sizeof(A) / sizeof(A[0]);

    selectionSort(A, size);

    printf("Отсортированный массив: \n");
    for (int i = 0; i < size; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");

    return 0;
}
*/
//this is 47
/*
int main(void) {
    int v;  // Ввод верхней границы
    int A[100; // Массив для хранения чисел
    int j, a, s, n, k;

    printf("Введите значение v: ");
    scanf("%d", &v);  // Ввод верхней границы v

    for (j = 0, a = 10; a < v && j < MAX_SIZE; a++) {
        for (s = 0, n = a; n != 0; n = n / 10) {
            k = n % 10;
            if (k != 0 && a % k != 0) {
                s = 1;
                break;
            }
        }
        if (s == 0) {
            A[j++] = a;  // Добавляем a в массив A
        }
    }

    // Вывод всех найденных чисел
    printf("Найденные числа:\n");
    for (int i = 0; i < j; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");

    return 0;
}
*/
//this is 48
/*
void removePairs(int A[], int *n) {
    int i, j;
    for (i = 0; i < *n - 1; i++) {
        if (A[i] == A[i + 1]) {
            // Удаление пары
            for (j = i; j < *n - 2; j++) {
                A[j] = A[j + 2];
            }
            *n = *n - 2; // Уменьшаем размер массива на 2
            i--; // Возвращаемся к предыдущему элементу
        }
    }
}

int main(void) {
    int A[] = {1, 2, 2, 3, 4, 4, 5};
    int n = sizeof(A) / sizeof(A[0]);

    removePairs(A, &n);

    // Печать результата
    printf("Массив после удаления пар: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", A[i]);
    }
    printf("\n");

    return 0;
}
*/
//this is 49
/*
int main(void) {
    int A[10] = {3, -1, 5, 7, -2, 9, 4, -3, 1, 0}; // Пример массива
    int i, k;

    for (i = 0, k = -1; i < 10; i++) {
        if (A[i] < 0) continue; // Пропускаем отрицательные элементы
        if (k == -1) {
            k = i; // Находим первый неотрицательный элемент
        } else if (A[i] < A[k]) {
            k = i; // Находим индекс минимального неотрицательного элемента
        }
    }

    // Вывод результата
    if (k != -1) {
        printf("Индекс минимального неотрицательного элемента: %d\n", k);
        printf("Минимальный неотрицательный элемент: %d\n", A[k]);
    } else {
        printf("Нет неотрицательных элементов.\n");
    }

    return 0;
}
*/
//this is 50.0000
/*
int main() {
    int A[10] = {1, -2, 3, 4, -5, 6, 0, -1, 7, 8}; // Пример массива
    int i, s = 0, k = 0;

    for (i = 0; i < 10; i++) {
        if (A[i] < 0) {
            k = 1;
        } else {
            if (k == 1) {
                s++;
            }
            k = 0;
        }
    }

    printf("Количество неположительных чисел после первого отрицательного: %d\n", s);
    return 0;
}
*/
//this is 51
/*
int main(void) {
    int A[10] = {3, 5, 7, 2, 8, 1, 9, 4, 6, 0}; // Пример массива
    int i, s;

    for (i = 0, s = 0; i < 10; i++) {
        if (A[i] > s) {
            s = A[i]; // Обновляем максимальное значение
        }
    }

    printf("Максимальное значение в массиве: %d\n", s); // Выводим результат

    return 0;
}
*/
//this is 52
/*
int main(void) {
    int A[10] = {0, 5, 3, 9, 1, 7, 2, 8, 6, 4}; // Пример массива
    int i, k;

    // Инициализация переменной k
    for (i = 1, k = 0; i < 10; i++) {
        if (A[i] > A[k]) {
            k = i; // Обновляем индекс наибольшего элемента
        }
    }

    printf("Индекс наибольшего элемента: %d\n", k);
    printf("Наибольший элемент: %d\n", A[k]);

    return 0;
}
*/
//this is 53
/*
 int main(void) {
     int A[10] = {3, -1, 2, 8, -5, 7, -2, 0, 5, -3}; // Пример массива
     int i, k;

     for (i = 0, k = -1; i < 10; i++) {
         if (A[i] < 0) continue; // Пропускаем отрицательные значения
         if (k == -1) k = i; // Устанавливаем k на первый положительный элемент
         else if (A[i] < A[k]) k = i; // Если текущий положительный элемент меньше, обновляем k
     }

     if (k == -1) {
         printf("Нет положительных элементов.\n");
     } else {
         printf("Минимальный положительный элемент: %d, индекс: %d\n", A[k], k);
     }

     return 0;
 }
 */

//this is 54

/*
 
 int main(void) {
     int A[10] = {3, -1, 2, 7, -3, 1, -5, 0, 4, 10}; // Пример массива
     int i, k;

     // Ищем минимальный положительный элемент
     for (i = 0, k = -1; i < 10; i++) {
         if (A[i] < 0) continue; // Игнорируем отрицательные числа
         if (k == -1 || A[i] < A[k]) k = i; // Обновляем индекс минимального положительного
     }

     // Проверяем результат
     if (k == -1) {
         printf("Положительных элементов нет.\n");
     } else {
         printf("Минимальный положительный элемент: %d (индекс %d)\n", A[k], k);
     }

     return 0;
 }
 */
//this is 55
/*
int main(void) {
    int A[10]; // Объявляем массив A размером 10
    int i, s = 0; // Инициализируем переменные i и s

    // Заполняем массив A (можно заменить на ввод с клавиатуры)
    for (i = 0; i < 10; i++) {
        printf("Введите элемент A[%d]: ", i);
        scanf("%d", &A[i]); // Считываем элемент массива
    }

    // Подсчет положительных элементов
    for (i = 0; i < 10; i++) {
        if (A[i] > 0) {
            s++; // Увеличиваем счетчик, если элемент положительный
        }
    }

    // Выводим результат
    printf("Количество положительных чисел в массиве: %d\n", s);

    return 0; // Завершение программы
}
*/

//this is 56
/* int main(void) {
 int A[10] = {-3, -2, 1, 2, -1, 0, 5, 7, -4, 2}; // Пример массива
 int i, s = 0; // Переменные i и s

 for (i = 1; i < 10; i++) {
     if (A[i] > 0 && A[i - 1] < 0) {
         s++; // Увеличиваем счетчик при переходе из отрицательного в положительное
     }
 }

 printf("Количество переходов из отрицательного в положительное: %d\n", s);
 return 0;
}*/
 //this is 57
/* int main() {
 int A[10] = {1, 2, 3, 2, 5, 6, 1, 2, 3, 4}; // Пример массива
 int i, s, k;

 for (i = 1, s = 0, k = 0; i < 10; i++) {
     if (A[i - 1] < A[i]) {
         k++;
     } else {
         if (k > s) {
             s = k;
         }
         k = 0; // Сбрасываем текущую длину
     }
 }
 
 // Проверка в конце, если последовательность закончилась на возрастающем элементе
 if (k > s) {
     s = k;
 }

 printf("Максимальная длина возрастающей последовательности: %d\n", s + 1); // +1, чтобы учесть первый элемент
 return 0;
}*/
//this is 58
/* int main() {
 int A[10] = {1, -2, -3, 4, -5, 6, -7, -8, 9, -10}; // Пример массива
 int i, s = 0, k = 0;

 for (i = 0; i < 10; i++) {
     if (A[i] < 0) {
         k = 1; // Обнаружено отрицательное число
     } else {
         if (k == 1) {
             s++; // Увеличиваем счетчик, если до этого было отрицательное
         }
         k = 0; // Сбрасываем флаг, т.к. текущий элемент положительный
     }
 }

 // Вывод результата
 printf("Количество последовательных отрицательных чисел: %d\n", s);
 return 0;
}*/

/*
  /\___/\
 ( o   o )
  > ^ <
 /     \
|       |
|       |
|       |
 \     /
  \___/
 
*/
